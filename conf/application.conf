# This is the main configuration file for the application.
# https://www.playframework.com/documentation/latest/ConfigFile

play.application.loader = "modules.StartTimeApplicationLoader"

play.http.errorHandler = handlers.ErrorHandler

play.modules.enabled += logging.LoggingModule
play.modules.enabled += logging.jmx.JMXModule

db.logging.driver=org.h2.Driver
db.logging.url="jdbc:h2:mem:terse-logback"
db.logging.username="sa"
db.logging.password=""

# https://docs.sentry.io/error-reporting/quickstart/?platform=java
sentry {
  enabled = false
  enabled = ${?SENTRY_ENABLED}

  dsn="https://some-random-key@sentry.io/1111"
  dsn=${?SENTRY_DSN}
}

# https://www.honeycomb.io/product-trial/
honeycomb {
  enabled = false
  enabled = ${?HONEYCOMB_ENABLED}

  writeKey = ""
  writeKey = ${?HONEYCOMB_API_KEY}

  team = ""
  team = ${?HONEYCOMB_TEAM}

  dataSet = "terse-logback-showcase"
  dataSet = ${?HONEYCOMB_DATASET}

  serviceName = "terse-logback-showcase"
}

files.enabled = true
files.enabled = ${?FILES_ENABLED}

logging.dispatcher {
  executor = "thread-pool-executor"
  throughput = 1
  thread-pool-executor {
    fixed-pool-size = 2
  }
}

logging.sql {

  // We can't use the serial id because we're using a DB pool and inserts can happen out of order.
  //
  // We can't use the timestamp alone because timestamp is only to microsecond and we can get several events
  // appended to ringbuffer in that period.  I think this is because JDK 8 uses system.currentTimeMillis
  // under the hood even though Instant is specced to nanoseconds.
  //
  // The event_id is a flake id which is k-ordered, and guaranteed to increment with a counter.
  //
  // But we can't use the event id alone because during startup(?), it's possible for the ERROR to have a
  // LOWER event_id than the debug and trace statement (I honestly don't know how this is possible)
  //
  // We can use System.nanoTime(), but that's unique to the JVM and resets at JVM start time...
  // So we use timestamp as primary, then (System.nanotime - NanoTime.start) as the secondary ordering.
  //
  // This obviously won't work in situations where we have multiple hosts writing to the same table, but
  // this is an example app and you have to stop somewhere.
  queryStatement = """select * from events order by ts, relative_ns limit ? offset ?"""

  byIdStatement = """select * from events where event_id = ?"""

  byCorrelationIdStatement = """
    select * from events where correlation_id = ? order by ts, relative_ns limit ? offset ?
  """

  truncateStatement = """truncate table events"""
}
